Additional context is provided below.

* Tests should be written in `pylint` and use `mocker` as needed. 
* Always use `mocker.patch.object` over `mocker.patch`
* Do not mock: logging functions, `tz`, `dateparser`
* When providing test datetime objects, use the builtin `d()` and `t()` functions defined below.
* If `return_value` is needed for a mock, define it as part of the call to `mocker.patch.object`.

```python
def d(i, h=0):
    """Returns a date based on an integer, for testing. d(0,0) is 2025-01-01 @ 0:00:00 ET"""
    # Impl omitted

def t(hour, weekday=0):
    """Create a datetime object from hour and weekday. t(0,0) is 2024-11-04 @ 0:00:00 ET"""
    # Impl omitted
```

```python
def test_example(mocker):
    """Test doc header"""
    mocker.patch.object(neon, "search_member", return_value=[])
    got = function_to_be_tested()
    assert got == "foo"
```

For functions decorated with `@command` that use `print_yaml`, style unit tests thusly:

```python
def test_no_response(mocker, capsys):
    """Test an example command and verify no yaml output""" 
    mocker.patch.object(lib, "method_used_by_command", return_value={})
    X().test_cmd(["--test_cli_argument"])
    captured = capsys.readouterr()
    got = yaml.safe_load(capsys.readouterr().out.strip())
    assert not got
```

Do not add comments to output code samples.

