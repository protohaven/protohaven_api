"""Commands related to sending communications"""
import argparse
import logging
import re
import sys
from collections import defaultdict

import yaml

from protohaven_api.commands.decorator import arg, command
from protohaven_api.integrations import (  # pylint: disable=import-error
    airtable,
    comms,
    neon,
)

log = logging.getLogger("cli.comms")


class Commands:  # pylint: disable=too-few-public-methods
    """Commands for sending Discord & email comms.

    Note that this does perform side effects e.g. cancelling a class
    """

    def _handle_comms_event(self, e, dryrun=True):
        """Handle a single entry in a comms YAML file"""
        for k, v in e.get("side_effect", {}).items():
            if k.lower().strip() == "cancel":
                log.info(f"Cancelling #{v}")
                if not dryrun:
                    neon.set_event_scheduled_state(str(v), scheduled=False)

        target = None
        if e["target"][0] in ("#", "@"):  # channels or users
            content = f"{e['subject']}\n\n{e['body']}"
            if dryrun:
                log.info(f"DRY RUN to discord {e['target']}")
                log.info(content)
            else:
                target = [e["target"]]
                comms.send_discord_message(content, target[0])
                log.info(f"Sent to Discord {target[0]}: {e['subject']}")
        else:
            email_validate_pattern = r"\S+@\S+\.\S+"
            emails = re.findall(
                email_validate_pattern,
                e["target"].replace(";", " ").replace(",", " ").lower(),
            )
            emails = [
                e.replace("(", "").replace(")", "").replace('"', "").replace("'", "")
                for e in emails
            ]

            if dryrun:
                log.info(f"\nDRY RUN to {', '.join(emails)}")
                log.info(f"Subject: {e['subject']}")
                log.info(e["body"])
            else:
                target = emails
                comms.send_email(
                    e["subject"], e["body"], target, e.get("html") or False
                )
                log.info(f"Sent to {target}: '{e['subject']}'")

        intents = e.get("intents")
        if intents and not dryrun:
            airtable.log_intents_notified(intents)
            log.info(f"Intents updated in airtable: {intents}")
        if target:  # Only set when not dry run
            airtable.log_comms(e.get("id", ""), ", ".join(target), e["subject"], "Sent")
            log.info("Logged to airtable")

    def _load_comms_data(self, path):
        """Fetch and parse a YAML file for use in comms"""
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f.read())
        log.info(f"Loaded {len(data)} notifications:")
        for e in data:
            log.info(f" - {e['target']}: {e['subject']}")
        return data

    @command(
        arg(
            "--path",
            help="path to comms YAML file (typically generated by another command)",
            type=str,
        ),
        arg(
            "--side-effects",
            help="also carry out side effects e.g. cancelling classes",
            action=argparse.BooleanOptionalAction,
            default=False,
        ),
        arg(
            "--confirm",
            help="skip interactive confirmation; use for true automation",
            action=argparse.BooleanOptionalAction,
            default=False,
        ),
        arg(
            "--dryrun",
            help="just print them, don't send them",
            action=argparse.BooleanOptionalAction,
            default=False,
        ),
    )
    def send_comms(self, args):
        """Reads a list of emails/discord messages and sends them to their recipients"""
        data = self._load_comms_data(args.path)
        if not data:
            log.info(f"{args.path} was empty, so nothing to do.")
            return

        side_effects = defaultdict(list)
        for e in data:
            for sa, sv in e.get("side_effect", {}).items():
                print(sa, sv)
                side_effects[sa] += [sv]

        confstr = f"send {len(data)} notifications"

        if args.side_effects and len(side_effects) > 0:
            log.info(
                f"Also carrying out the following side effects: {dict(side_effects)}"
            )
            confstr += " with side effects"

        if not args.dryrun and not args.confirm:
            confirm = input(f'Please type "{confstr}" to continue: ')
            if confirm != confstr:
                log.error("Confirmation string does not match; exiting")
                sys.exit(1)

        for e in data:
            self._handle_comms_event(e, args.dryrun)
        log.info("Done")
